(* An implementation in OCaml of Finite State automata                                         *)(* mainly following Simon Thompson's "Regular Expressions and Automata using Haskell"          *)(* University of Kent tech report 958                                                          *)(* John Hale Sun Jul 11 11:02:52 EDT 2004 *)(* updated by john Monday September 23rd 2013 *)(*  before: #use "utilities.ml";;  after: #use "visualizeNFA.ml"*)(* 11/20 adapted into fst for arabic morphology *)module Int =struct  type t = int  let compare = compareendmodule IntSet = Set.Make(Int)type move = int * (string option * string option) * intmodule Move =struct  type t = move  let compare = compareendmodule MoveSet = Set.Make(Move)type fst =  { states: IntSet.t;    start: IntSet.t;    final: IntSet.t;    transitions: MoveSet.t;}let emptyfst =  { states = IntSet.empty;    transitions = MoveSet.empty;    start = IntSet.empty;    final = IntSet.empty }(* take the limit of the sequence x, f x, f (f x), f (f (f x)), ... *)let rec setlimit f s =  let next = f s in  if (IntSet.equal s next) then s else setlimit f next(* where can we go from anywhere in the current state pool x *)(* following only Emove transitions ? *)let closure mach x =  let accessible = function stateset ->  (* almost identical to onemove *)    IntSet.fold      (fun srcstate dests ->	MoveSet.fold	  (fun (origin, (input, output), result) prev -> IntSet.union prev	    (match input with	      Some _ -> IntSet.empty	    | None -> if (origin=srcstate)	      then IntSet.singleton result	      else IntSet.empty))	  mach.transitions	  dests      )      stateset  (* include states that we're already in *)      stateset  (* but look for escape routes everywhere *)  in  setlimit (function foo -> IntSet.union foo (accessible foo)) x;;